library(readr)
library(nnet)
#install.packages("dummies")
library(dummies)
#creating the gradiant and hesian matrix
#function is computing Q matrix
#param X - matrix of X
#param Y - vector of Y
#return Q matrix
Q_component <- function(X,Y){
Q <- matrix( nrow=3, ncol=6)
for(k in 1:3){
for (j in 1:6){
ind = which(Y==k)
Xcol = unlist(X[,j][ind])
Q[k,j]=sum(Xcol)
}
}
return(t(Q))
}
#function is computing N matrix
#this is our deriative equation
#param X - matrix of X
#param B - matrix represntive of vector of original coefficients
#return N matrix
N_component <- function(X,B){
N <-matrix(, nrow=6, ncol=3)
for (a in 1:3){
for (r in 1:6){
v = rep(1,nrow(X))
I_r_a <- (X[,r]*exp((X%*%B)[,a]))/rowSums(exp(X%*%B)+v)
N[r,a] <- sum(I_r_a)
}
}
return(N)
}
#function of gradient
#param X - X matrix
#param Y - Y vector
#param B - matrix represntive of vector of original coefficients
#return gradient vector
gradiant <- function(X,Y,B){
gradiant_matrix <- Q_component(X,Y)-N_component(X,B)
return(gradiant_matrix)
}
#function of hessian
#param X - X matrix
#param B - matrix represntive of vector of original coefficients
#return hessian matrix
hessian <- function(X,B){
H <-matrix(0, nrow=18, ncol=18)
for (a in 1:3){
for (r in 1:6){
for (t in 1:6){
for (s in 1:3){
A <- exp(X%*%B)[,a]
v = rep(1,nrow(X))
M <- rowSums(exp(X%*%B)+v)
S <-  -exp(X%*%B)[,s]
if (s==a){
I <- -(X[,r]*X[,t]*A*(M-A))/(M*M)
} else {
I <- (X[,r]*X[,t]*A*S)/(M*M)
}
H[(a-1)*6+r,(s-1)*6+t] <- sum(I)
}
}
}
}
return(H)
}
#Netwon Raphson iteration for the multinomial regresion
newton_raphson_multinomial_mle <- function(B ,X,Y, epsilon)
{
dist <- 1
iter = 0
while(dist > epsilon){
iter = iter + 1
gradient = gradiant(X,Y,B)
gradient_vector <- matrix(unmatrix(gradient,byrow = FALSE))
beta <- matrix(unmatrix(B,byrow = FALSE))
hessian <- hessian(X,B)
beta_new =  beta - ((solve(hessian)) %*% gradient_vector)
dist=max(abs(beta_new-beta))
B <- matrix(beta_new, nrow = 6, ncol = 3, byrow=FALSE)
}
print(iter)
return(B)
}
#returns the sd of the estimator
# sd_estimator <- function(X,B){
#   sd_matrix <-solve(-hessian(X,B))
#   sd_vector <- sqrt(diag(sd_matrix))
#   return(sd_vector)
# }
#Q1.b
workdir = "C:/Users/Liav/Desktop/Uni/Regression/bochan2"
setwd(workdir)
occupation <- read.csv("occupation.csv")
head(occupation)
#function that make dummies
#param column - a column of X
#param X - X matrix
#return - new X matrix with dummies of column
make_dummies = function(column, X){
dum = dummy(column)
joined = cbind(X,dum)
joined = joined[,-length(joined)]
return(joined)
}
#create new data frame with dummies
occupation.dum = make_dummies(occupation$fatherOccup, occupation)
#remove the father occupation
occupation.dum = occupation.dum[,-1]
#create son occupation (y) numeric
occupation.dum[,1] = as.numeric(occupation.dum[,1])
#make black numeric
occupation.dum[,2] = ifelse(occupation.dum$black=="yes",1,0)
#Make nonintact numeric
occupation.dum[,3] = ifelse(occupation.dum$nonintact=="yes",1,0)
head(occupation.dum)
occupation_df <- data.frame()
#function that duplicate rows
#param x - the row
#param n - the number of times
rep.row<-function(x,n){
matrix(rep(x,each=n),nrow=n)
}
for (i in 1:nrow(occupation.dum)){
n <- as.numeric(occupation.dum[i,4])
occupation_df <- rbind(occupation_df,rep.row(occupation.dum[i,-4],n))
}
head(occupation_df)
#make numerics
occupation_df$V1 = as.numeric(occupation_df$V1)
occupation_df$V2 = as.numeric(occupation_df$V2)
occupation_df$V3 = as.numeric(occupation_df$V3)
occupation_df$V4 = as.numeric(occupation_df$V4)
occupation_df$V5 = as.numeric(occupation_df$V5)
occupation_df$V6 = as.numeric(occupation_df$V6)
#create Y vector
Y = as.matrix(occupation_df[,1])
#create X matrix
X = as.matrix(occupation_df[,-1])
X = cbind(1,X)
head(X)
head(Y)
Q = Q_component(X,Y)
X
B<-matrix(0, nrow=6, ncol=3)
N = N_component(X,B)
N
grad = gradiant(X,Y,B)
grad
K = hessian(X,B)
B
v = runif(18)
t(v)%*% K%*% v
#K is negative
N
dim(K)
isSymmetric(K)
det(K)
solve(K)
K
coef = newton_raphson_multinomial_mle(B,X,Y,0.0000001)
coef = newton_raphson_multinomial_mle(B,X,Y,0.0000001)
coef = newton_raphson_multinomial_mle(B,X,Y,0.01)
coef = newton_raphson_multinomial_mle(B,X,Y,0.0000001)
#Netwon Raphson iteration for the multinomial regresion
newton_raphson_multinomial_mle <- function(B ,X,Y, epsilon)
{
dist <- 1
iter = 0
while(dist - epsilon >0){
iter = iter + 1
print(iter)
gradient = gradiant(X,Y,B)
gradient_vector <- matrix(unmatrix(gradient,byrow = FALSE))
beta <- matrix(unmatrix(B,byrow = FALSE))
hessian <- hessian(X,B)
beta_new =  beta - ((solve(hessian)) %*% gradient_vector)
dist=max(abs(beta_new-beta))
B <- matrix(beta_new, nrow = 6, ncol = 3, byrow=FALSE)
}
return(B)
}
coef = newton_raphson_multinomial_mle(B,X,Y,0.0000001)
coef = newton_raphson_multinomial_mle(B,X,Y,0.01)
coef = newton_raphson_multinomial_mle(B,X,Y,1)
#this is it
t(coef)
coef = newton_raphson_multinomial_mle(B,X,Y,0.9)
#function of hessian
#param X - X matrix
#param B - matrix represntive of vector of original coefficients
#return hessian matrix
hessian <- function(X,B){
H <-matrix(0, nrow=18, ncol=18)
for (a in 1:3){
for (r in 1:6){
for (t in 1:6){
for (s in 1:3){
A <- exp(X%*%B)[,a]
v = rep(1,nrow(X))
M <- rowSums(exp(X%*%B)+v)
S <-  exp(X%*%B)[,s]
if (s==a){
I <- -(X[,r]*X[,t]*A*(M-A))/(M*M)
} else {
I <- (X[,r]*X[,t]*A*S)/(M*M)
}
H[(a-1)*6+r,(s-1)*6+t] <- sum(I)
}
}
}
}
return(H)
}
coef = newton_raphson_multinomial_mle(B,X,Y,0.000001)
#this is it
t(coef)
#Netwon Raphson iteration for the multinomial regresion
newton_raphson_multinomial_mle <- function(B ,X,Y, epsilon)
{
dist <- 1
iter = 0
while(dist > epsilon){
print(dist-epsilon)
iter = iter + 1
print(iter)
gradient = gradiant(X,Y,B)
gradient_vector <- matrix(unmatrix(gradient,byrow = FALSE))
beta <- matrix(unmatrix(B,byrow = FALSE))
hessian <- hessian(X,B)
beta_new =  beta - ((solve(hessian)) %*% gradient_vector)
dist=max(abs(beta_new-beta))
B <- matrix(beta_new, nrow = 6, ncol = 3, byrow=FALSE)
}
return(B)
}
coef = newton_raphson_multinomial_mle(B,X,Y,0.000001)
#function of hessian
#param X - X matrix
#param B - matrix represntive of vector of original coefficients
#return hessian matrix
hessian <- function(X,B){
H <-matrix(0, nrow=18, ncol=18)
for (a in 1:3){
for (r in 1:6){
for (t in 1:6){
for (s in 1:3){
A <- exp(X%*%B)[,a]
v = rep(1,nrow(X))
M <- rowSums(exp(X%*%B)+v)
S <-  (-1)*exp(X%*%B)[,s]
if (s==a){
I <- -(X[,r]*X[,t]*A*(M-A))/(M*M)
} else {
I <- (X[,r]*X[,t]*A*S)/(M*M)
}
H[(a-1)*6+r,(s-1)*6+t] <- sum(I)
}
}
}
}
return(H)
}
coef = newton_raphson_multinomial_mle(B,X,Y,0.000001)
#install.packages('gdata')
#install.packages('nnet')
library(gdata)
library(readr)
library(nnet)
#install.packages("dummies")
library(dummies)
#creating the gradiant and hesian matrix
#function is computing Q matrix
#param X - matrix of X
#param Y - vector of Y
#return Q matrix
Q_component <- function(X,Y){
Q <- matrix( nrow=3, ncol=6)
for(k in 1:3){
for (j in 1:6){
ind = which(Y==k)
Xcol = unlist(X[,j][ind])
Q[k,j]=sum(Xcol)
}
}
return(t(Q))
}
#function is computing N matrix
#this is our deriative equation
#param X - matrix of X
#param B - matrix represntive of vector of original coefficients
#return N matrix
N_component <- function(X,B){
N <-matrix(, nrow=6, ncol=3)
for (a in 1:3){
for (r in 1:6){
v = rep(1,nrow(X))
I_r_a <- (X[,r]*exp((X%*%B)[,a]))/rowSums(exp(X%*%B)+v)
N[r,a] <- sum(I_r_a)
}
}
return(N)
}
#function of gradient
#param X - X matrix
#param Y - Y vector
#param B - matrix represntive of vector of original coefficients
#return gradient vector
gradiant <- function(X,Y,B){
gradiant_matrix <- Q_component(X,Y)-N_component(X,B)
return(gradiant_matrix)
}
#function of hessian
#param X - X matrix
#param B - matrix represntive of vector of original coefficients
#return hessian matrix
hessian <- function(X,B){
H <-matrix(0, nrow=18, ncol=18)
for (a in 1:3){
for (r in 1:6){
for (t in 1:6){
for (s in 1:3){
A <- exp(X%*%B)[,a]
v = rep(1,nrow(X))
M <- rowSums(exp(X%*%B)+v)
S <-  exp(X%*%B)[,s]
if (s==a){
I <- -(X[,r]*X[,t]*A*(M-A))/(M*M)
} else {
I <- (X[,r]*X[,t]*A*S)/(M*M)
}
H[(a-1)*6+r,(s-1)*6+t] <- sum(I)
}
}
}
}
return(H)
}
#Netwon Raphson iteration for the multinomial regresion
newton_raphson_multinomial_mle <- function(B ,X,Y, epsilon)
{
dist <- 1
iter = 0
while(dist > epsilon){
print(dist-epsilon)
iter = iter + 1
print(iter)
gradient = gradiant(X,Y,B)
gradient_vector <- matrix(unmatrix(gradient,byrow = FALSE))
beta <- matrix(unmatrix(B,byrow = FALSE))
hessian <- hessian(X,B)
beta_new =  beta - ((solve(hessian)) %*% gradient_vector)
dist=max(abs(beta_new-beta))
B <- matrix(beta_new, nrow = 6, ncol = 3, byrow=FALSE)
}
return(B)
}
#returns the sd of the estimator
# sd_estimator <- function(X,B){
#   sd_matrix <-solve(-hessian(X,B))
#   sd_vector <- sqrt(diag(sd_matrix))
#   return(sd_vector)
# }
#Q1.b
workdir = "C:/Users/Liav/Desktop/Uni/Regression/bochan2"
setwd(workdir)
occupation <- read.csv("occupation.csv")
head(occupation)
#function that make dummies
#param column - a column of X
#param X - X matrix
#return - new X matrix with dummies of column
make_dummies = function(column, X){
dum = dummy(column)
joined = cbind(X,dum)
joined = joined[,-length(joined)]
return(joined)
}
#create new data frame with dummies
occupation.dum = make_dummies(occupation$fatherOccup, occupation)
#remove the father occupation
occupation.dum = occupation.dum[,-1]
#create son occupation (y) numeric
occupation.dum[,1] = as.numeric(occupation.dum[,1])
#make black numeric
occupation.dum[,2] = ifelse(occupation.dum$black=="yes",1,0)
#Make nonintact numeric
occupation.dum[,3] = ifelse(occupation.dum$nonintact=="yes",1,0)
head(occupation.dum)
occupation_df <- data.frame()
#function that duplicate rows
#param x - the row
#param n - the number of times
rep.row<-function(x,n){
matrix(rep(x,each=n),nrow=n)
}
for (i in 1:nrow(occupation.dum)){
n <- as.numeric(occupation.dum[i,4])
occupation_df <- rbind(occupation_df,rep.row(occupation.dum[i,-4],n))
}
head(occupation_df)
#make numerics
occupation_df$V1 = as.numeric(occupation_df$V1)
occupation_df$V2 = as.numeric(occupation_df$V2)
occupation_df$V3 = as.numeric(occupation_df$V3)
occupation_df$V4 = as.numeric(occupation_df$V4)
occupation_df$V5 = as.numeric(occupation_df$V5)
occupation_df$V6 = as.numeric(occupation_df$V6)
#create Y vector
Y = as.matrix(occupation_df[,1])
#create X matrix
X = as.matrix(occupation_df[,-1])
X = cbind(1,X)
head(X)
head(Y)
Q = Q_component(X,Y)
X
B<-matrix(0, nrow=6, ncol=3)
N = N_component(X,B)
N
grad = gradiant(X,Y,B)
grad
K = hessian(X,B)
B
v = runif(18)
t(v)%*% K%*% v
#K is negative
N
dim(K)
isSymmetric(K)
det(K)
solve(K)
K
#newton_raphson_multinomial_mle(B,X,Y,0.000000001)
beta <- matrix(unmatrix(B,byrow = FALSE))
Q_component(X,Y)
View(K)
solve(K)
solve(hessian(X,B))
coef = newton_raphson_multinomial_mle(B,X,Y,0.000001)
coef_vec = matrix(unmatrix(coef,byrow = FALSE))
coef_vec
#check
X_new <- as.data.frame(X)
X_new
model = multinom(Y ~ X_new$V1 + X_new$V2 + X_new$V3 + X_new$V4 + X_new$V5 + X_new$V6)
#this is it
t(coef)
model
#amazing
#special thanks to Proff. DZ for help and motivation support
#define the workdir
workdir = "C:/Users/Liav/Desktop/Uni/Data"
setwd(workdir)
data = read.csv("NationalNames.csv")
data
View(data)
install.packages(dplyr)
library(dplyr)
data.group_by("Year")
data %>% group_by("Year")
group_by(data, Year)
group_by(data, Year)
group_by(data, Year)
group_by(data, Year)
group_by(data, Name)
sum(data$Count)
data$count/sum(data$Count)
data$count = data$count/sum(data$Count)
data$count = data$count / sum(data$Count)
data$count = data$count %/% sum(data$Count)
data$count = data$count* sum(data$Count)
data = read.csv("NationalNames.csv")
data$count
data = read.csv("NationalNames.csv")
data$Count
data$Count\sum(data$count)
data$Count\sum(data$Count)
sum(data$Count)
data$Count/2
data$Count/sum(data$Count\)
data$Count/sum(data$Count)
aggregate(data, by=list(Category=data$Name), FUN=sum)
library(tidyr)
head(data)
data %>% group_by(Year, Gender) %>%
summarise(total_loan_amount =sum(Count)) %>%
spread(gender, Count) %>%
ungroup() %>%
transmute(country = country,  female_percent = F / (F+M), male_percent = M /(F+M))
data %>% group_by(Year, Gender) %>%
summarise(total_loan_amount =sum(Count)) %>%
spread(Gender, Count) %>%
ungroup() %>%
transmute(country = country,  female_percent = F / (F+M), male_percent = M /(F+M))
head(data)
data %>% group_by(Year, Gender) %>%
summarise(total_loan_amount =sum(data$Count)) %>%
spread(Gender, Count) %>%
ungroup() %>%
transmute(country = country,  female_percent = F / (F+M), male_percent = M /(F+M))
data %>% group_by(Year, Gender) %>%
summarise(total_loan_amount =sum(data$Count))
data %>% group_by(Year, Gender, Name) %>%
summarise(total_loan_amount =sum(data$Count))
data %>% group_by(Year, Gender, Name) %>%
summarise(total_loan_amount =sum(data$Count))

---
title: "ex3"
author: '20474862 + 203340530'
date: "17 ×‘×™×•× ×™ 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#ggplot2 is used to make plots
library(ggplot2)
#library stringr is used for regex
library(stringr)
#tidyr for different dataframe methods
library(tidyr)
#coloring
library(RColorBrewer)
#for using pipes
library(dplyr)



```
##Part I - Parsing a data file
**Here we parse the data that helped make the gapminder figures (see Lecture 6).**
First, we can read the parsing_gap_minder_messy.txt file into r using readLines and print a few rows.

```{r}
data <- readLines("parsing_gap_minder_messy.txt" )
head(data)
```
**a. We want to make sure that every line starts with a country name. Write a command that checks that every line of the data starts with a capital letter exactly once (no other capital letters follow it).** 

```{r}
#save all places in data which start with capital Letter from A-Z
data_cap = data[str_which(data, "^[A-Z]")]
```

What we did was to find all the indexes which their first letter is capital from A to Z.

**b. Now let’s match against the continent. Here are the possible continents: Africa,Eruope,Americas,Asia,Oceania. Use the propoper regexp to check that every line has at least one of these continents.**

```{r}
#these is our pattern
contintens = "Africa|Europe|Americas|Asia|Oceania"
#againg same method
data_cont = data_cap[str_which(data, contintens)]
```

We filtered all the bad rows. Now let's go on:
** C.create a table of the data. Use the following columns >> country, year, population, continent, lifeExp, gdpPercap. Generate a regex with groups to extract this information from the data. Make sure that all lines are properly read. Hint: the life expectancy and gdp can be whole numbers (instead of fractions).**


```{r}
ptrn = "([A-Z][a-z]+[:punct:]?[A-Z]?[a-z]*[:punct:]?[A-Z]?[a-z]*[:punct:]?)([12][0-9]{3})(\\d*)([A-Z][a-z]+)(\\d*.\\d*)G(\\d*.\\d*)"
parsed_data = as.data.frame(str_match(data_cont,ptrn))[2:7]
colnames(parsed_data) = c("Country","Year","Population","Continent","LifeExp","GDP")
```
The use with regex and grouping is very elegant. We can solve this complicated problem only with two lines of code.
Now All we need to do is connect all columns together:
```{r}
head(parsed_data)
```

##Part 2 - Black jack simulator

We would like to research the House Strategy of a black jack game, which say that player should stop drawing cards when
the sum of his hand is over 17. It called so because most of casino dealers play with that method.
To approximate the probabillity to win the casino when the player and the house plays the same method, we will 
run a big enough amount of multinomial experiments and see what is the estimator we get.

a. Write a function that draws from a card deck.
To simplify our game, and since (J Q K) all equal to 10, we won't use the royalty LETTERS but values.
```{r}
workdir = "C:\\Users\\Liav\\Desktop\\Uni\\R\\targil3"
set.seed(123)
setwd(workdir)
```

**a. Write a function that draws from a card deck.**
```{r cars}

#this function draw a randon element from vector and keeps it
#param deck - the vector we pop from
#param hand - the keeper  
#return hand - the keeper
draw_card = function(deck, hand){
  #random card index
  rand = round(runif(1, min = 1, max = length(deck)))
  #pick a random card
  card = deck[rand]
  #take out the card from deck
  deck <<- deck[-rand]
  #add to hand
  hand = c(hand, card)
  return(hand)
}
```

Before we go on, we will need a functiob that compute the best sum of the hand, considering rules of black jack.
```{r}
#this function is computing the bset sum for the hand
#param hand - a vector of cards
#return the best sum player can get in blackjack (include above 21, but then compute the minimum)
sum_hand = function(hand){
  #if no cards picked yet
  if(length(hand)==0){
    return(0)
  }
    #if player got Ace
    if( "A" %in% hand){
      #get aces index
      aces = which(hand == "A")
      #check sum without ace
      hand_without_aces = as.numeric(hand[-aces])
      #best strategy for player in different cases:
      if(sum(hand_without_aces)<=10){
        if(length(aces)==1){
          return(sum(hand_without_aces)+11)
        }
        if(length(aces==2)){
          return(sum(hand_without_aces)+12)
        }
        if(length(aces==3)){
          return(sum(hand_without_aces)+13)
        }
        if(length(aces==4)){
          return(sum(hand_without_aces)+14)
        }
      }
      #more best strategies in case sum is more then 10
      else{
          if(length(aces)==1){
          return(sum(hand_without_aces)+1)
        }
        if(length(aces==2)){
          return(sum(hand_without_aces)+2)
        }
        if(length(aces==3)){
          return(sum(hand_without_aces)+3)
        }
        if(length(aces==4)){
          return(sum(hand_without_aces)+4)
        }
      }
      
      
    }
  #if no ace, return the sum of the hand
  else{
    return(sum(as.numeric(hand)))
  }
}
```


**b. Write a function that compares two black-jack hands - House and Player - and decides who wins.**
Rules:
If one hand is > 21, that side loses.
If both hands > 21, Player loses.
If both hands equal, Player loses.
If Player > House, Player wins.
Ace counted as 1 or 11, whichever is better.

```{r}
#this function compare the sums of the hands and return the winner
#param sum_house - the sum of the houses hand
#param sum_player - the sum of the players hand
#return the winner's name (string)
compare_sums = function(sum_house, sum_player){
  if (sum_player>21 & sum_house<=21){
    return("House")
  }
  if (sum_house>21 & sum_player<=21){
    return("Player")
  }
  if (sum_house>21 & sum_player>21){
    return("HOUSE")
  }
  else{
    if(sum_house>=sum_player){
      return("HOUSE")
    }
    else{
      return("Player")
    }
  }
  
}
```

**c. House strategy: House always draws more cards until 17, then stops. Write function that draws house strategy.**
```{r}
#this function is the house strategy function
#house keep drawing until he have over 17
#param house - the house hand
#return - house hand (list)
house_strategy = function(house){
  while(sum_hand(house)<17){
  house = draw_card(deck, house)
  }
  return(house)
}

#this funciton initialize a game
#param n_decks - number of decks
init_game= function(n_decks){
  #initialize house hand
house <<- c()
  #initialize player's hand
player <<- c()
#initialize list of cards, four 10's for one 10 and 3 pictures
cards <<- c("A",2,3,4,5,6,7,8,9,10,10,10,10)
#initialize deck
deck <<- rep(rep(cards, 4),n_decks)
}
```
**d. If Player playes house strategy, what is player probability of winning? Estimate using Monte-Carlo. Choose number of repeats (B) so that std-deviation of your is low enough.**

```{r}
#initialize columns for summary data frame
df = data.frame()
house_vec = c()
player_vec = c()
sum_house_vec = c()
sum_player_vec = c()
winner_vec = c()
wins=c()
j=0
n=10000
for (i in 1:n){
  init_game(4)  
  house = house_strategy(house)
  player = house_strategy(player)
  house_vec = c(house_vec,list(house))  
  player_vec = c(player_vec, list(player))
  sum_house_vec = c(sum_house_vec, sum_hand(house))
  sum_player_vec = c(sum_player_vec, sum_hand(player))
  winner = compare_sums(sum_hand(house), sum_hand(player))
  winner_vec = c(winner_vec, winner)
  if (winner=="Player"){
    j=j+1
    wins = c(wins, j)
  }
  else{
    wins = c(wins,j)}
}
games = seq(1:length(wins))
library(ggplot2)
res = as.data.frame(cbind(games, wins))
df = data.frame(sum_house_vec,sum_player_vec, winner_vec)
p = length(which(df$winner_vec=="Player"))/n
print(paste0("After " ,n, " repeats, the probability of player wins is: " ,p))
#to see all games print df

```

We would also like to check wheather the player wins spread nicely, or if there is a peak of winnings in a row.
Let's make the plot of the games vs. wins:

```{r}
ggplot(data=res, aes(y=games,x=wins))+ geom_step() + ggtitle("Games vS. Wins over the experiment")

```



**e. Use normal approximation to give 95% interval for the probability of Player winning if Player plays House strategy.**
Based on the Central limit theorem, given high number of experiments (B big enough) we can assume the winning probabillity distribute Normal.
We would like to approximate the probabillity of Player winning, given 95% confidence level.
To do so, We will make a Confidence Interval for the Winning proportion, with the following equation we learned on Statistic Principles course:

<center>
![Proportion Confidence Interval](C:/Users/Liav/Desktop/Uni/R/targil3/proportion_rs.png)
</center>


```{r}



#choose the significance level, ??
alpha = 0.05
#create our statisti from normal distribution table
z = qnorm(p = 1-alpha/2)
#create the root
b = sqrt(p*(1-p)/n)
upper = p + z*b
lower = p - z*b
#print thee interval
interval = c(lower,upper)
interval
```




##Part 3 - Monopoly

**We will study the number of turns it takes to go through the board of Monopoly. In the game of Monopoly (îåðåôåì), you get 200$ every time you pass the starting position (“GO” or “ãøê öìçä”). The board is square with 10 stops on each side, so going through the full board takes 40 steps. In each turn you throw a pair of dice, and walk the total sum of the points. If you get a double (for example 2,2) you walk the number of points and get to throw again at the same turn.**

**a.Write a simulator of one monopoly turn.**

Before we start, and as we learned in part two, we would like to see that the dice chance to double distribution after a big amount of experiments is normal.

Let's build the dice roll function:

```{r}
roll_dice = function(){
dice1 = sample(1:6,1)
dice2 = sample(1:6, 1)
return (c(dice1,dice2))
}
```
  
before we go on, it is interesting to see if the doubles are distributed Normal.
```{r}

dices = roll_dice()
dices

#create a means empty vector
means = c()
#for 1000 times we would like to run a Monte-Carlo
#and check if the averages for each monte carlo experiments dist. normal.
for(i in 1:1000){
  vec = c()
  n=1000
  count=0
  for (i in 1:n){
    a = roll_dice()
    dic1 = a[1]
    dic2 = a[2]
  if (dic1 == dic2){
      count = count +1
  }
  vec = c(vec, count/n)
  mean(vec)  
  }
  means = c(means, mean(vec))
}
hist(means,15)
```


**b. Call the number of turns it takes to get to at least 40 steps T. Write a simulator that generates T.**
First, Let's make a function that counts the plyer steps:

```{r}


go = function(steps_player_x){
  dices = c(0,0)
  while(dices[1] == dices[2]){
     dices = roll_dice()
     steps_player_x = steps_player_x + sum(dices) 
  }
  return(steps_player_x)
}
```

**c. Run a Monte Carlo experiment and draw the distribution of T.**

And now, we can finally run the experiment :
```{r}
monte_nopoly = function(n,t){
  T_all = c()
  for (i in 1:t){
    T_vec = c()
    for (i in 1:n){
      player1 = 0
      T=0
      while(player1<=40){
        player1 = go(player1)
        T = T+1
      }
      T_vec = c(T_vec, T)
    }
    T_all = c(T_all, mean(T_vec))
  }
  return(T_all)
}

monte_vec = monte_nopoly(100,10000)
```

**d.Calculate the mean and the standard deviation of T.**

**e. Is the distribution of T approximately normal? Use plots and discuss.**

To find if the distribution of the number of turns to a full round is distributed normally, we can compare 3 graphs:

1. The histogram of our Monte-Carlo result - bins are colored with **Blue**

2. The normal Distribution density with same mean and sd as the Monte Carlo Results vector - colored with **Red**

3. The Density of our specific Monte-Carlo Experiment - colored with **Yellow*
```{r}
# Density plots with semi-transparent fill
a = ggplot(as.data.frame(monte_vec), aes(x=monte_vec))+ scale_colour_manual(name = 'Legend', guide = 'legend', breaks = c("Histogram"='blue', 'Normal Dist'='red','Density'='yellow'),values = c('blue', 'red','yellow')) +
  geom_histogram(data = as.data.frame(monte_vec), aes(x=monte_vec, y=..density..), binwidth=0.05, colour="white", fill="darkblue") + geom_density(fill="yellow", alpha=.3, color = "blue") + stat_function(fun = dnorm, args = list(mean = mean(monte_vec), sd = sd(monte_vec)), col='red', size=1) + ggtitle("Number of Turns to a Monopoly full round",subtitle = "Density, Histogram and Normal Dist.")
a
```


We can see that all these 3 plots are significantly similar. Therefor, We can say that T is approximately Normal distibuted.


###Part 4  Open problem simulator
Here you will repeat Question 3 for some problem you are interested in.
####a.Identify a question and form some probability model you can sample from.

In this question we will analyze the "multiplication model" in gambling at roulette, a link to a Wikipedia page that explains the model: [https://he.wikipedia.org/wiki/%D7%9E%D7%A8%D7%98%D7%99%D7%A0%D7%92%D7%9C_(%D7%A9%D7%99%D7%98%D7%AA_%D7%94%D7%99%D7%9E%D7%95%D7%A8%D7%99%D7%9D)]

This model reflects common biases in the general public that do not understand statistics in depth and thinks that it is possible to "beat the casino" by using the method described. In this section we will break the conventional wisdom by constructing a suitable model for playing on roulette over time using the method and proving that not only can not "beat The casino" in this method, but the loss is even greater than just a random bet on roulette.
Basic assumptions and parameters:

1. A gambler comes to a casino with capital X and leaves the casino only when he reaches AX where A represents the percentage of profit from his initial capital.
(for example: if x=100 and he want to duble his capital, A=2 and he leave the casino when he have 200 in he's pocket)
2. He's inital bet is w, every seqence he win W so he have incentive for high W from one hand but in the other - if W high he can loose his money much faster.
3. when he's capital go to 0 he leave the casino with lost of X.
4. He's strategy is to bet on a red/black in the rollete only, following the model instructure.
5. when he win some seqence he win duoble wht he bet (actual bet).
6. he continue gambling in a seqence until he'll win AX or lose all X.
7. The rollete probability to win in one play is y~ Ber(18.125/37) since if the rollete stop on 0 he get half of he's money (European rollete)
8. for each seqence he need to win ones before he lost all his money, and each lost he bet twice (like the model strategy) so:
9.to win in a seqence: 
X-sum((2^i)*W)>0 when i range is 0:number of losts
to lose in a seqence:
X-sum(2^i*W)<0.
The game: 
a. we'll defined one function to describe each round, every time we'll sample y(i)~Ber(18.125/37) when 1 it's win and 0 it's lost.
b. every round if he'll win he'll get double the actual bet and his money for the next round will be X_real +2*actual_bet.
C. If he'll lose in a game the function will check if he have enough money for another round and if yes the amount will deducted from he's real time money X_live and we'll sample another y(i)~Ber(18.25/37) and so on.

parameters: X_initial = the starting point capital
            W = the first-bet amount he choosed

**Here the function for one rollete round**

```{r}

round<- function (X_initial, W){
  X_real<- X_initial # he start the round with all the money he have
  losts_counter<- 0 #how many rounds he lost
  last_bet<- FALSE # check if it the last bet he can do
  show_live<-c(rep(0,10000)) # to check the money situtaion during the round
    for (i in 1:10000){
      required_bet<- W*2^losts_counter # this is the amount he suppoused to bet by the model
        if (X_real>= required_bet) {actual_bet=required_bet}
        else {actual_bet=X_real # if he doesn't have enough money he bet everything he have
              last_bet<- TRUE}
          
          X_real<- X_real-actual_bet
          show_live[i]<-X_real # the actual money lefted every round
          y<- rbinom(1,1,(18.125/37)) # this is the rollete result
            if (y==1){show_live[i+1]<-X_real+actual_bet*2 # winning situation
                      new_x<-X_real+actual_bet*2 # the total amount after winning
              round_result<- list(new_x, show_live[1:(losts_counter+2)])
                      return(round_result)}
            else if (last_bet) {round_result<-list(0, show_live[1:(losts_counter+1)] ) 
                                return(round_result)} # loosing all situation
            else {losts_counter = losts_counter + 1}
          
          }
}

```

example for a round:
```{r}
sample_round<- round(1000,50)
'Money He have now'
sample_round[[1]]
'Whats happend in the round'
sample_round[[2]]

```




9. He play number of seqences to reach AX when every round he get extra money for winning, so the X_initial growth (unless he was on the "last_bet") 
10.for example if he wasn't on "the last bet" situation the number of seqences he need to go out as a winner its Wk=AX and when he determinate A,X,W we can defined how many seqences are required: k=AX/W.

The second function describe one casino day when he's playing few rounds until he get the AX or loose everything

parameters: X_initial= The money he came with
            A= The win he want (precents from he's initial capital)
            W= The original bet amount
            
**Here the function for all day**
            
```{r}

casino_day<- function(X_initial,A,W){
  
  # first condition: when the gambler have AX_initial he leave the casino as a winner,          otherwise he keep playing
 
  X_live<-X_initial # he start the day with the money he came with
  money_tracker<- c()
  for (i in 1:10000) {if (X_live < A*X_initial) { # If he get AX he go out
    round_results<-round(X_live,W) # Here the rounds plays
    a<-round_results[2]
    b<-c()
    for (i in 1:length(a[[1]])){b[i]<-a[[1]][i]} # with this function we can track the money situation during the rounds and during the days 
        X_live<- as.numeric(round_results[1])
        money_tracker<-append(money_tracker,b)
          if (X_live==0){day_result<- list('looser',money_tracker)
                            return(day_result)}}
          if (X_live >= A*X_initial){day_results<-list('winner',money_tracker)
          return(day_results)}
    
  }
  
}



```

check random 10 day's at the casino with the same parameters:

```{r}
X_initial<-500
A<- 3
W<- 20
sample_days<- data.frame('Result'=rep(NA,10),'How_many_rounds'=rep(0,10),'what_happend'=rep(NA,10))
for (i in 1:10){ # Each day as a random variable when he loose or win
temp<- casino_day(X_initial,A,W)
sample_days$Result[i]<- temp[[1]]
sample_days$How_many_rounds[i]<- length(temp[[2]])
sample_days$what_happend[i]<- temp[2]
}
```

**Total winnigs & How many rollete rounds on average a day**


```{r}
'Days he won out of 10'
sum(sample_days$Result=='winner')
'How many rollete rounds on average was at every day'
mean(sample_days$How_many_rounds)
```

**Whats happend**
```{r}

for (i in 1:10) {

    x<-length(sample_days$what_happend[[i]])
    dat<-data_frame(1:x,sample_days$what_happend[[i]])
     names(dat) <- c('Round','real time money')
     temp<- ggplot(dat, aes(x=dat$Round, y=dat$`real time money`))+
      geom_line(color= "red")+
      scale_x_continuous(name ="Rollete Round")+
      scale_y_continuous(name ="Real Time Money")+
        ggtitle(sample_days$Result[i])
   print(temp)
}

```

####B.Write a simulation function for the random variable you are interested in.

Now, assuming that wer'e going to the casino every day with 1,000 Dollar and gambling all the amuont on one color (red/Black) and leaving, the expected amount that we'll have after 500 days at the casino its 2*(18.125/37)*500*1,000=~ 489,864 Dollars.
Let's check:(We won't get the excactly ampunt becouse all of the 500 days it's one experiment, but at the expected return we'll)
```{r}
# This function describe dumb gambler that make only one bet a day, and get double or nothing. 
# Every day he start with 1000 Dollar and he go the casino 500 day's 
dumb_gambler<- function(){
total_money<- 0
for (i in 1:500) {
  money_today<-1000
  y<-rbinom(1,1,18.125/37)
  total_money<-total_money+ money_today*2*y
}
return(total_money)}
dumb_gambler()
```

And our gambler, that spending much more time next the rollete and way more safisticated - came with strategy and a statistic model - how much he will have after 500 days with same strategy and same parametrs? 

To isolate the parameters effect we'll choose A=2 (excactly like the other gambler) and lets see how much money he have in he's pocket after 500 days of gambling.
And let see How much he get:
(again, one experiment)

```{r}
# This function describe 'smart gambler' that gambling with the 'multipication model on the rollete' 
# Every day he come to the casino with 1000 dolar and bet like the model instruction until he got 2000 dolar or lose all
smart_gambler<-function(){
total_money_smart<- 0
for (i in 1:500) {
  W<- runif(1,20,300)
  day_i<- casino_day(1000,2,W)
  if (day_i[[1]]=='winner'){total_money_smart<-total_money_smart+2000}
}
return(total_money_smart)}
smart_gambler()
```

**To make clear - The total amount each gambler have after 500 casino days this is T, the random variable** 

###C. Run a Monte Carlo experiment and draw from the distribution of the random variable.

 becouse it's not completly clear what method is better we'll take each gambler to try he's strategy over 1000 times (or- we'll take 1000 gamblers in each strategy) and we'll check the total amount every seqence, this is our variable T = Total amount after 500 days of gambling with each strategy.
So T_stupid it's for the dumb gambler
and T_smart it's for the strategy one. Let's see they distributions:
```{r}
# This function take some time to run, 1000000 ittaration (linear).
T_stupid<-c(rep(0,1000))
for (i in 1:1000) {
  T_stupid[i]<- dumb_gambler() # collect the data from each experiment
  }
T_smart<-c(rep(0,1000))
for (i in 1:1000) {
  T_smart[i]<- smart_gambler()# collect the data from each experiment
  }
```




### D.Calculate the mean and the standard deviation of T.
```{r}
'T_smart'
mean(T_smart)
var(T_smart)^0.5
'T_stupid'
mean(T_stupid)
var(T_stupid)^0.5
```


### E. Is the distribution approximately normal? If not, can you find a different approxiamtion? Use plots and discuss.

Yea it seems quite normal, and its come from seqence of Ber experiment so it's binom in large numbers - Normal. 
Here for proof beside the math - qqplot

```{r}
qqnorm(T_smart);qqline(T_smart, col = 2)
qqnorm(T_stupid);qqline(T_stupid, col = 2)
```

From the qq-plot seems that T distribute quite normal. 

And we can also add a density plot for both,
For T_smart: 
```{r}
T_data = data.frame(T_smart,T_stupid)
   head(T_data) # make a dtat frame to use ggplot
   
   # get mean for each group
   mu_stupid <- mean(T_data$T_stupid)
   mu_smart <- mean(T_data$T_smart)
# create basic ggplot
   basic_plot_smart <- ggplot(T_data, aes(x = T_smart))+
  
# Change y axis to count instead of density
     geom_density(aes(y = ..count..), fill = "lightgray") +
        geom_vline(aes(xintercept = mu_smart), 
             linetype = "dashed", size = 0.6,
             color = "#FC4E07")
   basic_plot_smart
   
```

For T_stupid:
```{r}
# create basic ggplot
   basic_plot_stupid <- ggplot(T_data, aes(x = T_stupid))+
  
# Change y axis to count instead of density
    geom_density(aes(y = ..count..), fill = "lightgray") +
  geom_vline(aes(xintercept = mu_stupid), 
             linetype = "dashed", size = 0.6,
             color = "#FC4E07")
basic_plot_stupid
```


Both in the same Graph:

```{r}

gridExtra::grid.arrange(basic_plot_smart,basic_plot_stupid)
```









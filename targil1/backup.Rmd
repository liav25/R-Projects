---
title: "ex1"
author: '20474862'
date: "20 באפריל 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#we will use readxl library to read .xls files
library("readxl")
library(dplyr)
```
###Pisa Test
####1.1 
First we will want to load our Pisa test excel files. To do that, we'll define our work directory to be the folder that contains the 'pisa.xlsx' file, with the command wordkir.
As the 'pisa.xlsx' contains 3 sheets, we will load each of them to a different reference.

```{r}
workdir = "C:/Users/Liav/Desktop/Uni/R/targil1"
setwd(workdir)

pisa_math = read_excel("pisa.xlsx", sheet=1)
pisa_reading = read_excel("pisa.xlsx", sheet=2)
pisa_science = read_excel("pisa.xlsx", sheet=3)

```

To get a clue about how the data looks like, we can use the head command to pring the first rows of it. Let's make an example with pisa_math.

```{r}
head(pisa_math)
```

Since all the worksheets share the same columns names, to differ them, we can change some of the columns name.
```{r}
colnames(pisa_math)[2] = "math_score"
colnames(pisa_reading)[2] = "reading_score"
colnames(pisa_science)[2] = "science_score"  

```

####1.2 
We would like to check who were the leading countries in every field in 2015. To do so, we will sort by descending order the 2015 year subset. This command might seem very complicated, let's try to explain it simply:

1. head command (x, n= 3L) is the same head command we used before, but now we used "n=3L" to get the first 3 lines.

2. pisa_math[y, year=2015] command gives us a susbet of the pisa_math rows that their value in column 'year' equals to 2015.
   notice that pisa_math is the name of the dataframe, we can change it later to another name for the other dataframes.
   
3. order(pisa_math$math_score, decreasing = TRUE) returns the data decreasing order if the data frame be the pisa_math column.

To connect those three simple functions we can write the 3rd function instead of y, and the joined 2nd function (with 3 insted of y) instead of x, and now we got the 3 first countries orederd by scores, only when year was 2015.
```{r}
head(subset(pisa_math[order(pisa_math$math_score, decreasing = TRUE), ], year == 2015), n=3L)
head(subset(pisa_science[order(pisa_science$science_score, decreasing = TRUE), ], year == 2015), n=3L)
head(subset(pisa_reading[order(pisa_reading$reading_score, decreasing = TRUE), ], year == 2015), n=3L)

```
We can see that Singapore students has the best Pisa test grades in 2015, in all fields.

####1.3
To continue working on this data set, we would like to merge the all three dataframes to one.
For this, we can use the merge command. At first we merge the science and math grades columns. 
The command "all=TRUE" used to keep the NA value rows. 
The "sort=TRUE" command used to keep the new dataframe sorted by the country name. 

After we merged science and math grade we can merge them again to the reading grade dataframe by the same method. 

```{r}
data = merge( merge( pisa_math, pisa_science, by = c("Country","year") ,all = TRUE, sort = TRUE), pisa_reading, by = c("Country","year"), all = TRUE, sort=TRUE )

```
Here is ther head of our new merged dataframe:
```{r ,echo=FALSE}
head(data, n=7L)
```
 
Before we continue to answer the next questions, we would like to make sure that the columns type is still numeric, so we can apply arithmetic functions on them.
For that, we'll use the following:
```{r}
sapply(data, class)
```
 We can see that the type of the values in the score columns are character. There for, we'll use sapply to apply the function as numeric on the 3rd to 5th columns.
```{r}
data[, 3:5] <- sapply(data[, 3:5], as.numeric)
sapply(data, class)
```
And now we can see the type changed to numeric.


####1.4 
We'll check the avarage pisa scores (average of all three fields scores) for each country on every year. To make it a fair competition, we will calculate only the rows that includes all three grades.
```{r}
data$average_score <- rowMeans(data[,3:5], na.rm=TRUE)
```
Here is ther head of our new dataframe, with the average column:
```{r ,echo=FALSE}
head(data, n=3L)
```
####1.5
As beofre, let's use the subset and order functions to present the top average scores countries in 2006 and 2015.
This time, we will use "[,c(1,6)]" slicing to show only the 1st, 2nd and 6th column.

```{r}
head(subset(data[order(data$average_score, decreasing = TRUE), ], year == 2015)[,c(1,2,6)], n=3L)
head(subset(data[order(data$average_score, decreasing = TRUE), ], year == 2006)[,c(1,2,6)], n=3L)
```
***

###Salaries
Now, we'll start working on the salaries file.

2.1
From a brief look on the data, we can see that the 2nd sheet on the sal.xlsx file is just an addition of a nonimnal salary column.
Therefor, to save time and code, it will be a good idea to join the two dataframes by adding the "current" column from the 2nd dataframe to the first one.
We' will use the same read_excel command from before to do so, and than we'll just add manually the missing column.

```{r}
salaries = read_excel("sal.xlsx", sheet=1)
sal_nominal = read_excel("sal.xlsx", sheet=2)
salaries$current = sal_nominal$current
```
Here is the head of our new dataframe:
```{r, echo=FALSE}
head(salaries, n=3L)
```



#REFRESSION

```{r}

salary_predict <- function(row, i) {

df <- data.frame(x=1:14,y=100*(1:14))
df$y = as.vector(unlist(salaries[i,2:15]))
df$x= as.numeric(colnames(salaries[2:15]))

model <- lm(y~x+1,data=df)

df$y_ip <- predict.lm(model, newdata = df)

df= df %>% mutate(y = ifelse(is.na(y), y_ip, y))

return(df$y)
}

for(i in 1:nrow(salaries)) {
    print(i)
    row <- salaries[i,]
    
    salaries[i,2:15] =  salary_predict(row,i)
}

View(salaries)


# do stuff with row


```
df <- data.frame(x=1:14,y=100*(1:14))
df$y = as.vector(unlist(salaries[1,2:15]))

df$x= as.numeric(colnames(salaries[2:15]))
df
model <- lm(y~x+1,data=df)
predict(model, newdata = df)

#df$y_ip[!is.na(df$y)] <- predict.lm(mod1, data=df)
#df$y_ip2 <- predict.lm(mod1, newdata = df)
df$y_ip <- predict.lm(model, newdata = df)

df


df=
 df %>%   mutate(y = ifelse(is.na(y), y_ip, y))



df
 
df <- data.frame(x=1:13,y=(1:13))
df$y[5] <- NA
df$y[8] = NA
df$x = as.numeric(colnames(salaries[3:15]))
df
mod1 <- lm(y~x+1,data=df)


df




(2017/col)*current


## Including Plots
```
